from typing import Final
import os
import datetime

import asyncio

from dotenv import load_dotenv
import discord
from discord import Intents, Client, Message
from responses import getResponse



#loads token so user cant see
load_dotenv()
TOKEN: Final[str] = os.getenv("DISCORD_TOKEN")

#Pokemon array
#name, type1, type2, hp, atk, physDef, spAtk, spDef, spd, image
from Pokemon import Pokemon

pokeArray = [Pokemon("Charizard", "fire", "flying", 266, 155, 144, 200, 157, 184, "")
, Pokemon("Blastoise", "water", "none", 268, 153, 184, 157, 193, 144, "")
, Pokemon("Venusaur", "grass", "poison", 270, 152, 153, 184, 184, 148, "venusaur.png")]

#bot setup
global cole
cole = False
intents: Intents = Intents.default()
intents.message_content = True #NOQA
client: Client = Client(intents = intents)

#message system
async def send_message(message: Message, user_message: str, uName: str) -> None:
    if not user_message:
        print("Message was empty because intents were not enabled (i think)")
        return

    if is_private := user_message[0] == "?":
        user_message = user_message[1:]

    #prints either to channel or to user depending on whether there is a question mark in there
    try:
        response: str = getResponse(user_message)
        if response != "":
            if response == "startTimerForge":
                #t1 = Thread(target = forgeTimer, args = (message,))
                #t1.start()
                await forgeTimer(message, getCole())
            elif response == "startTimerRift":
                await riftTimer(message)
            elif response == "coleMode":
                setCole(True)
                await message.author.send("Cole mode activated!")
            else:
                await message.author.send(response) if is_private else await message.channel.send(response)
    except Exception as e:
        print(e)

def getCole():
    global cole
    return cole
def setCole(bool):
    global cole
    cole = bool
#startup
async def forgeTimer(message, cole):
    if cole:
        hourAdd = 10
        minuteAdd = 30
    else:
        hourAdd = 14
        minuteAdd = 0
    hourFinish = (int(datetime.datetime.now().strftime("%H")) + hourAdd) % 24
    minuteFinish = int(datetime.datetime.now().strftime("%M")) + minuteAdd
    modifier = ""
    if hourFinish < 12:
        modifier = "A.M."
    else:
        modifier = "P.M."
    if minuteFinish >= 60:
        hourFinish += 1
        minuteFinish -= 60

    if minuteFinish < 10:
        minuteFinish = "0" + str(minuteFinish)
    hourFinish = hourFinish % 12
    if hourFinish == 0:
        hourFinish = 12
    timeFinish = str(hourFinish) + ":" + str(minuteFinish)
    await message.author.send(f"Your forge timer has started, come back at {timeFinish} {modifier}")
    if cole:
        await asyncio.sleep(37800)
    else:
        await asyncio.sleep(50400)
    await message.author.send("Your forge timer is up!")#50400 for 14 hours

async def riftTimer(message):
    await message.author.send("Rift mote timer started, come back in 2 hours")
    await asyncio.sleep(7200)
    await message.author.send("Collect your motes!")


async def startBattle(message, pokemon, username):
    await message.channel.send(f"You have run into a wild **{pokemon.name}!**")
    numChoice: int = 0
    while(numChoice < 1 or numChoice > 3):
        await message.channel.send("Pick a number 1 - 3 to decide what pokemon you fight with")
        msg = await client.wait_for('message', check=lambda message: message.author == username)
        try:
            if int(msg) > 0 or int(msg) < 4:
                await message.channel.send("You have chosen " + pokeArray[int(msg)])
        except Exception as e:
            print(e)


@client.event
async def on_ready() -> None:
    print(f"{client.user} is now running")

@client.event
async def on_message(message: Message) -> None:
    if message.author == client.user:
        return

    username: str = str(message.author)
    user_message: str = message.content
    channel: str = str(message.channel)

    print(f"[{channel}]  {username}: {user_message}")
    await send_message(message, user_message, username)

async def send_image(channel, image_path):
    with open(image_path, 'rb') as f:
        picture = discord.File(f)
        await channel.send(file=picture)
#entry point
def main() -> None:
    client.run(token = TOKEN)

if __name__ == "__main__":
    main()
